<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0,minimal-ui:ios">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <link rel="stylesheet" href="">
    <script src=""></script>
    <style>
        /* 弹性容器 */
        .parent {
            display: flex;
            /* 设置主轴方向  */
            flex-direction: row;
            /* 设置主轴内容分布 */
            justify-content: space-around;
            width: 800px;
            height: 800px;
            margin: 0 auto;
            border: 1px solid #ccc;
            /* 设置侧轴内容分布 单行*/
            /* align-items: center; */
            /* 设置换行 */
            flex-wrap: wrap;
            /* 设置侧轴内容分布 多行 */
            align-content: space-evenly;
            
        }

        .child {
            width: 200px;
            height: 200px;
            background-color: royalblue;
            text-align: center;
            line-height: 200px;
        }
    </style>
</head>

<body>
    <!-- 
弹性布局：
    弹性容器：设置了display:flex;的这个元素为弹性容器，里面的子元素会按照弹性布局的方式进行布局
        弹性容器外及弹性子元素内是正常渲染的。弹性盒子只定义了弹性子元素如何在弹性容器内布局
    弹性子元素：设置了display：flex；的弹性容器的直接子元素
    flex-direction: 设置主轴方向 定义弹性容器中弹性子元素 行排列还是列排列
        默认设置flex-direction:row；行排列（从左到右） 如果子元素过多，一行放不下，会自动压缩子元素（不会溢出也不会自动换行）
        flex-direction:row-reverse  行排列（从右到左）如果子元素过多，一行放不下，会自动压缩子元素（不会溢出也不会自动换行）
        flex-direction:column 列排列（从上到下） 如果子元素过多，一列放不下，会自动压缩子元素（不会溢出也不会自动换列）
        flex-direction:column-reverse （从下到上）如果子元素过多，一列放不下，会自动压缩子元素（不会溢出也不会自动换列）
    justify-content: 设置主轴子元素分布情况
        默认设置justify-content:flex-start 向主轴的开始位置靠拢
        justify-content:flex-end 向主轴的结束位置靠拢
        justify-content: center  向主轴中心位置靠拢
        justify-content:space-between 弹性项目平均分布在该行上。如果剩余空间为负或者只有一个弹性项，则该值等同于flex-start。
            否则，第1个弹性项的外边距和行的main-start边线对齐，而最后1个弹性项的外边距和行的main-end边线对齐，
            然后剩余的弹性项分布在该行上，相邻项目的间隔相等。
        justify-content:space-around 弹性项目平均分布在该行上，两边留有一半的间隔空间。如果剩余空间为负或者只有一个弹性项，则该值等同于center。
        否则，弹性项目沿该行分布，且彼此间隔相等（比如是20px），同时首尾两边和弹性容器之间留有一半的间隔（1/2*20px=10px）。
        justify-content:space-evenly 弹性项目平均分布在该行上，两边留有相同的间隔空间。如果剩余空间为负或者只有一个弹性项，则该值等同于center。
        否则，弹性项目沿该行分布，且彼此间隔相等（比如是20px），同时首尾两边和弹性容器之间留有一样的间隔（20px）。
    align-items: 设置侧轴子元素分布情况（单行）
        默认值align-items:stretch 拉伸 意思就是如果没有指定子元素的侧轴值的话(auto),会自动拉伸至盒子边缘
        align-items:flex-start 向侧轴的开始位置靠拢
        align-items:flex-end 向侧轴的结束位置靠拢
        align-items:  向侧轴中心位置靠拢
    flex-wrap: 设置换行
        默认值flex-wrap:nowrap 不换行
        wrap 换行（当主轴不够放的之后就换行）该情况下弹性子项溢出的部分会被放置到新行，子项内部会发生断行
        flex-wrap:wrap-reverse 反转wrap 的排列
    align-content: 设置侧轴子元素分布情况（多行）各个行的对齐
        align-content:stretch  默认。各行将会伸展以占用剩余的空间
        align-content:flex-start  各行向弹性盒容器的起始位置堆叠
        align-content:flex-end    各行向弹性盒容器的结束位置堆叠
        align-content:center      各行向弹性盒容器的中间位置堆叠
        align-content:space-between 各行在弹性盒容器中平均分布
        align-content:space-around  各行在弹性盒容器中平均分布，两端保留子元素与子元素之间间距大小的一半
        align-content:space-evenly  各行在弹性盒容器中平均分布，两端保留子元素与子元素之间间距大小一样
    order：n 用整数值来定义排列顺序，数值小的排在前面。可以为负值（是子元素的属性）
        设置的值越小排序越靠前
    align-self: 单独设置某个弹性子元素在侧轴上的排布
        align-self:auto 如果'align-self'的值为'auto'，则其计算值为元素的父元素的'align-items'值，
                        如果其没有父元素，则计算值为'stretch'
        align-self:flex-start 弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界
        align-self:flex-end 弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界
        align-self:center 弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，
                        则会向两个方向溢出相同的长度）
        等等
-->
    <div class="parent">
        <div class="child">1</div>
        <div class="child">2</div>
        <div class="child">3</div>
        <div class="child">1</div>
        <div class="child">2</div>
        <div class="child">3</div>
        <div class="child">1</div>
        <div class="child">2</div>
        <div class="child">3</div>
        <div class="child">1</div>
        <div class="child">2</div>
        <div class="child">3</div>
    </div>
</body>

</html>